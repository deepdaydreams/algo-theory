<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Runtime Analysis</title>

    <!-- Bootstrap Core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Scrolling CSS -->
    <link href="../css/scrolling-nav.css" rel="stylesheet">

    <!-- Slider CSS -->
    <link href="../css/bootstrap-slider.min.css" rel="stylesheet">

    <!-- Select CSS -->
    <link href="../css/bootstrap-select.min.css" rel="stylesheet">


    <!-- Off Canvas CSS -->
    <link href="../css/jasny-bootstrap.min.css" rel="stylesheet">

    <!-- Main CSS -->
    <link href="../css/main.css" rel="stylesheet">

    <!-- Visualization CSS -->
    <link href="./runtime-analysis.css" rel="stylesheet">

    <!-- MathJax JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>

</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">

    <!-- Off Canvas Menu -->
    <nav id="offCanvasMenu" class="navmenu navmenu-default navmenu-fixed-right offcanvas" role="navigation">
      <a class="navmenu-brand" href="../index.html"><b>Algo Theory</b></a>
      <ul class="nav navmenu-nav">
        <li><a href="../data-structures/index.html">Data Structures</a></li>
        <li><a href="../graph-traversal/index.html">Graph Traversal</a></li>
        <li><a href="../recursion/index.html">Recursion</a></li>
        <li><a href="../sorting-algorithms/index.html">Sorting Algorithms</a></li>
        <li class="active"><a href="../runtime-analysis/index.html">Runtime Analysis</a></li>
      </ul>
    </nav>
    <!-- Navigation -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
        <div class="container">
            <button type="button" class="navbar-toggle" data-toggle="offcanvas" data-target="#offCanvasMenu" data-canvas="body">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand page-scroll" href="#page-top">Runtime Analysis</a>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
                <ul class="nav navbar-nav">
                    <!-- Hidden li included to remove active class from about link when scrolled up past about section -->
                    <li class="hidden">
                        <a class="page-scroll" href="#page-top"></a>
                    </li>
                    <li>
                        <a class="page-scroll" href="#first">Big Oh Notation</a>
                    </li>
                    <li>
                        <a class="page-scroll" href="#second">Recursive Runtimes</a>
                    </li>
                    <li>
                        <a class="page-scroll" href="#third">Expected Runtimes</a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </div>

    <!-- Intro Section -->
    <section id="intro" class="intro-section">
        <div class="container">
            <div class="row">
                <div class="col-xs-12">
                    <h1>Runtime Analysis</h1>
                    <p class="text-center">In order to choose the right algorithm for a problem, computer scientists must be able to estimate how long an algorithm will take to run. Here we discuss three important concepts in algorithmic analysis: big Oh notation, recursive runtimes, and expected runtimes. </p>
                </div>
            </div>
            <div class="row">
                <div class="col-xs-4">
                    <a class="page-scroll" href="#first">
                        <div class="icon" id="linearRegression_img"></div>
                        <h3>Big Oh Notation</h3>
                    </a>
                </div>
                <div class="col-xs-4">
                    <a class="page-scroll" href="#second">
                        <div class="icon" id="correlation_img"></div>
                        <h3>Recursive Runtimes</h3>
                    </a>
                </div>
                <div class="col-xs-4">
                    <a class="page-scroll" href="#third">
                        <div class="icon" id="anova_img"></div>
                        <h3>Expected Runtimes</h3>
                    </a>
                </div>
            </div>
        </div>
        <div class="nextSection">
            <a class="page-scroll" href="#first">
                <img src="../img/nextSection.png" width="50px"/>
            </a>
        </div>
    </section>

    <!-- Services Section -->
    <section id="first" class="first-section">
    <div class="container">
        <div class="row">
            <div id="plotDie" class="col-xs-8">
            </div>
            <div class="col-xs-4">
                <h1>Big Oh Notation</h1>
                <hr>
                <p> To gauge algorithmic runtimes, computer scientists invented the big Oh notation system of measuring algorithmic runtimes. Loosely speaking, if we say that an algorithm runs in O(f(n)) time, we mean that in the worst case scenario our algorithm's runtime will be at most some constant multiple of f(n), where n is our input size and f is some mathematical function, and that this constant multiple rule always holds beyond a certain point. In the plot to the left, notice that the green plots seem to have a similar shape to one another and similarly the blue plots seem to have a similar shape, but the shapes are different between colors. That's because the blue algorithms, merge sort and quicksort, would be classified in the big Oh notation sysystem as O(nlogn) algorithms, while the green algorithms, bubble sort and insertion sort, would be classified as O(n^2) algorithms but not O(nlog n) algorithms. Try hovering over the graph to see what this looks like numerically.</p>
                <div id="barDie"></div>
            </div>
        </div>
    </div>
    <div class="nextSection">
        <a class="page-scroll" href="#third">
            <img src="../img/nextSection.png" width="50px"/>
        </a>
    </div>
    </section>

    <!-- Contact Section -->
    <section id="second" class="second-section">
        <div class="container">
            <div class="row">
                <div class="col-xs-8">
                     <div id='svgComb'></div>
                     <div class="button">
                        <input id="number2" data-slider-id="greenSlider" type="text" data-provide="slider" data-slider-ticks="[0,1]" data-slider-ticks-labels='["0","1"]' data-slider-min="0" data-slider-max="1" data-slider-step="1" data-slider-value="0"data-slider-tooltip="hide">
                        <input id="number" data-slider-id="blueSlider" type="text" data-provide="slider" data-slider-ticks="[0,1]" data-slider-ticks-labels='["0","1"]' data-slider-min="0" data-slider-max="1" data-slider-step="1" data-slider-value="0"data-slider-tooltip="hide">
                    </div>
                </div>
                <div class="col-xs-4">
                    <h1>Recursive Runtimes</h1>
                    <hr>
                    <p>Finding the runtime of an algorithm such as "find the minimum of an unsorted array" is straightforward: we check every element from front to back, and in the worst case, the minimum is at the very end, so the runtime is at most a constant multiple of the input size, i.e. O(n).  How do we measure the runtimes of more complicated algorithms, in particular recursive algorithms? For that purpose we have the Master Theorem, which states that if a recursion can be written as $$T(n) = \color{green}{a}T(n/\color{blue}{b}) + \color{orange}{f(n)}$$ the runtime can be exactly determined. In this diagram, the green slider represents a, the number of branches, and the blue slider represents b, how large each recursive subproblem is relative to the original input size. f(n) represents the amount of time we spend on each recursive problem. Try moving the sliders around to see how the amount of time, represented by the total area, changes for different values in the formula.</p>
                    <!--
                    <div>
                      <select class="form-control" id="sizeComb">
                        <option data-content="<div id='balls_1'></div>">1</option>
                        <option data-content="<div id='balls_2'></div>">2</option>
                        <option data-content="<div id='balls_3'></div>">3</option>
                        <option data-content="<div id='balls_4'></div>">4</option>
                      </select>
                    </div>
                    -->
                    <label class="radio-inline"><input type="radio" name="radioComb" value=true>$$\color{orange}{O(n)}$$</label>
                    <label class="radio-inline"><input type="radio" name="radioComb" checked="checked" value=false>$$\color{orange}{O(n^2)}$$</label>
                    <div class='explanationComb' style='display:none'>
                        <p>O(n) time work at each recursive level is a fairly common paradigm. Examples of such algorithms include merge sort and quicksort. It assumes that somehow we must traverse the entire input before we can proceed to the next part of the algorithm.
                    </div>
                    <div class='explanationComb'>
                        <p>This category occurs when we need quadratic time at each recursive level in order to fully process our input. Examples of such algorithms include matrix multiplication and Strassen's Algorithm. 
                    </div>
                </div>
            </div>
        </div>
        <div class="nextSection">
            <a class="page-scroll" href="#third">
                <img src="../img/nextSection.png" width="50px"/>
            </a>
        </div>
    </section>


    <!-- Contact Section -->
    <section id="third" class="third-section">
        <div class="container">
            <div class="row">
                <div class="col-xs-4">
                    <h1>Expected Runtimes</h1>
                    <hr>
                    <p>Worst case analysis is fantastic at guaranteeing our algorithm will always run at some minimum speed. However, sometimes considering average runtime yields much more insight into how fast an algorithm will actually take to run. In the accompanying ilustration, we have a classic use case for expected runtimes, namely hash tables. A hash table is a data structure which maps keys to values, and allows for more general access schemes. The illustration is implemented using chained hashing, i.e. every key corresponds to a bucket of corresponding values, here implemented as a linked list. By having many possible buckets and a good hash function to assign keys, we reduce the average amount of time per operation assuming random assignment. Try pressing the "Insert random key" and "Delete random key" to get a better feel for this data structure. Even though in the worst case we may end up with very time-consuming arrangements, i.e. keys all hashed to the same bucket, the average amount of keys per bucket (the expected value) is low, hence the usefulness of the hash table.</p>
                    <div id="coinWrapper">
                        <div id="coinButtons">
                            <div class="btn btn-default" id="enqueue" onclick="manualAddToTail()">Insert random key</div>
                            <div class="btn btn-default" id="dequeue" onclick="manualRemoveElement()">Delete random key</div>
                        </div>
                    </div>
                </div>
                <div class="col-xs-8">
                    <div id="svg_anova"></div>
                </div>
            </div>
        </div>
    </section>

    <!-- D3 -->
    <script src="../js/d3.min.js"></script>

    <!-- jQuery -->
    <script src="../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../js/bootstrap.min.js"></script>

    <!-- Scrolling Nav JavaScript -->
    <script src="../js/jquery.easing.min.js"></script>
    <script src="../js/scrolling-nav.js"></script>

    <!-- Off Canvas Menu JavaScript -->
    <script src="../js/jasny-bootstrap.min.js"></script>

    <!-- Slider JavaScript -->
    <!-- Don't forget to include JS and CSS for libraries you import! -->
    <script src="../js/bootstrap-slider.min.js"></script>

    <!-- Select JavaScript -->
    <script src="../js/bootstrap-select.min.js"></script>

    <!-- jstat -->
    <script src="../js/jstat.min.js"></script>
    
    <!-- Tool Tip JavaScript -->
    <script src="../js/d3.tip.v0.6.3.js"></script>

    <!-- Main JavaScript -->
    <script src="../js/main.js"></script>

    <!-- Visualization JavaScript -->
    <script src="./runtime-analysis.js"></script>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-206672906-1', 'auto');
      ga('send', 'pageview');

    </script>


</body>

</html>
